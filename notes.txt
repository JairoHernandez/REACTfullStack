https://github.com/StepheGrider/FullstackReactCode
https://mlab.com/login/

Download most up to data node version.
https://nodejs.org/en/download/current/

Also, install npm version of at least 5.5.

-----Heroku Deployment Checklist-----

1) Dynamic Port Binding.

server/index.js
    const PORT = process.env.PORT || 5000;

2) Tell Heroku which nodejs version to use. By default, Heroku will try to use an old version of node, which will likely crash the app.

Video uses "node": "8.1.1", "npm": "5.0.3", but i'm using newer version.

server/package.json
    "engines": {
        "node": "8.9.1",
        "npm": "5.5.1" 
    }

3) Tell Heroku to startup nodejs server via start script.

From "sripts" remove "test": "echo \"Error: no test specified\" && exit 1" and add this.

"scripts": {
    "start": "node index.js"
  }

4) We dont want give Heroku our dependencies. We let Heroku decide installing those.

.gitignore
    node_modules


-----Verifying Heroku Deployment-----

jairomh@ubuntu64-DevOps:~/REACTfullStack/server$ heroku create
Creating app... done, â¬¢ aqueous-earth-73690
https://aqueous-earth-73690.herokuapp.com/ | https://git.heroku.com/aqueous-earth-73690.git


-----Overview of Passport JS-----

Passport will not do this well.
    Automates vast majority of the OAUTH flow but not the entire things.
    Passport library structure is composed of 2 libraries.
        passport(core that is always installed by you):
            General helpers for handling auth in Express apps.
        passport strategy(requires installing at least one of these):
            Helpers for authentication with on very specific method(email/password, Google, Facebook, etc.).
            If you want to have Google, Facebook, Twitter authentication then you need to install one passport strategy for each one.

-----Passport Setup-----

server$ npm install --save passport passport-google-oauth20

-----Enabling Google OAUTH API-----

Go here https://console.developers.google.com
Click on Add API and search for Google+ API since it contains OAUTH. 
Enable it. Create credentials. Click Oauth client ID.

Oauth clientID:  [check keys.js]
    This is public token and accessible to outside world that identifies application to Google server(s).
client secret:  [check keys.js`]
    Do not share this with anyone.

How to securely store your secret(text value) if you push it to Github?
    Create config/keys.js and in the keys.
    Add keys.js to .gitignore

        Oauth clientID = googleClientID (capital D is important)
        client secret = googleClientSecret

        Notice how we prepend with 'google' to decipher between other Oauth providers like Facebook.

-----Authorized redirected URIs-----

This URI is entirely security related so users dont get tricked by sending their flow over to some hacker.com

    redirect_uri=http%3A%2F%2Flocalhost%3A5000%2Fauth%2Fgoogle%2Fcallback&

Google will return this page at the start of all this auth setp so click on it.

    Visit https://console.developers.google.com/apis/credentials/oauthclient/864190731953-egqj70f75jtofjs2fvsbi2136ip7p72u.apps.googleusercontent.com?project=864190731953 to update the authorized redirect URIs.

    Then under 'Authorized redirect URIs' change http://localhost:5000/* to http://localhost:5000/auth/google/callback

-----OAuth Callbacks-----

Now try to hit http://localhost:5000/auth/google/. It will load a page with 'Cannot GET /auth/google/callback'
It will also load this in the browser URL bar. See it had the code!!!
    http://localhost:5000/auth/google/callback?code=4/fGudjAYLVSl3swMg2FEUufDV0YcrtNZcpv6sx-CiPHQ#

Hit http://localhost:5000/auth/google/ a second time to see our callback be told to execute.

    (accessToken) => { 
    console.log(accessToken);

-----Access and Refresh Tokens-----

-----Nodemon setup-----
REACTfullStack/server$ npm install --save nodemon

Append this to "scripts" section in package.json.
    
    dev": "nodemon index.js"

-----HTTP is Stateless-----

Ajax requests are still HTTP requests. HTTP is stateless.
Server gives us back a token. This token is used as proof by client to tell Server that it already
knows who the client is and the request is safe, since it has record of such token.

OAUTH will use cookie based authentication.

Header inside HTTP packet from Google server will have property 'Set-Cookie', which will hold
the token that will uniquely identify user.
The browser will strip off the token and store it in browser's memory.
Browser will then append that cookie to follow-up requests.
The REACT side of things knows nothing about the cookie authentication, which is great because
the browser will manage this all for us.

Cookie based approach does have shortcomings.
For example, different strategies like JSON web tokens(talk about it later).

-----Signing In Users with Oauth-----

For regular email/password login recognizing the user when they log in is straighforward.
But with Oauth for Google you have to use user's google Id because it will never change. over time.

    profile: { id: '103507278511115330517'

    Because we are placing out trust in Google if Google decides to change the id we are screwed.
    That's how Oauth works so we are making the ASSUMPTION the googleId will not change.
    As far as Oauth all we really care to know is just the Google Id.

-----Introduction to MongoDB-----

SQL                                               | NoSQL
==================================================|===============================================================
Table                                             | Collection(Array of objects(aka Document(s)))
Row/Record                                        | Document
Schema based(columns, column guaranteed to exist) | Schemaless(mix of fields, which is good for data mining)
column                                            | field

-----MonogDB Steup-----

Remote ohsthing of mongoDB is a lot easier then local hosting of it.
DBname: emaily-dev
    DBusername: <see config/key.js>
    DBpassword: <see config/key.js>

-----Connecting Mongoose to MongoDB(remote)-----

If you see or NOT see this warning it's fine. 

~/REACTfullStack/server$ node index.js 
(node:5297) DeprecationWarning: `open()` is deprecated in mongoose >= 4.11.0, use `openUri()` instead, or set the `useMongoClient` option if using `connect()` or `createConnection()`. See http://mongoosejs.com/docs/connections.html#use-mongo-client
Db.prototype.authenticate method will no longer be available in the next major release 3.x as MongoDB 3.6 will only allow auth against users in the admin db and will no longer allow multiple credentials on a socket. Please authenticate using MongoClient.connect with auth credentials.

Just shows how mongoose is interacting with mongoDB.
Until mongoose fixes this there's nothing we can do so get used to them and keep giong.

-----Mongoose Model Classes-----

Don't put models in index.js since that file is more for loading and booting up are app.
Shifting thoughts to mongoDB(not mongoose). MongoDB can have variant amounts of properties(fields) per record(row).
However, mongoose will kinda remove the variant and enforce a Schema.

-----Saving Model Instances(CREATES USER ON REMOTE MONGODB)-----

When is it an appropriate time to create this new user??

DO NOT export model class from User.js and import into passport.js because it will really mess
up future tests with mocha, jest, etc. This will cause you to create copies of the same user
model, which those testing frameworks will yell at. To resolve this do this.
Create model class in passport.js like this.

    passpost.js
        // !TIP:  1 arg means we are fetching out of mongoose.
        // 2 args means we are loading into mongoose.
        // This is our true model Class.
        const User = mongoose.model('users'); 

And leave this as is in User.js

    User.js
        // !TIP:  1 arg means we are fetching out of mongoose.
        // 2 args means we are loading into mongoose.
        mongoose.model('users', userSchema); // Again this loads schema into mongoose.

-----Mongoose Queries-----

serializeUser function is going to be called by passport with our user model that we fetch in the first login step.
Refer to 'fist login step' diagram in notes.txt.
We are going to use that user model as our identifying piece of user information.
This info will be passed back to passport.
Passport will stuff cookie into token and send token to user.

deserializeUser function will be called by passport when a user client with its cookie makes a request to our server.
A request such as 'Can I have a list of my posts?'.
deserializeUser function will turn cookie into unique user model that identifies user.
The user is the passed into passport telling passport the user is real and authenticated so let's give user their list
of posts that belong to them.

-----Deserialize Cookies-----

-----Enabling Cookies-----

Out of the box express has no idea how to handle cookies.
To manage cookies in our app.

~/REACTfullStack/server$ npm install --save cookie-session

Then add them into

    passport.js
        const cookieSession = require('cookie-session'); // Give access to cookies.
        const passport = require('passport'); // Makes use of cookies.

and into

    index.js
        app.use(
            cookieSession({
        app.use(passport.initialize());
        app.use(passport.session());

-----Testing Authentication-----

    authroutes.js
        req.user is short for request.user.

            app.get('/api/current_user', (req, res) => {
                res.send(req.user);
            });

To see if you're getting your cookie go to here again.
http://localhost:5000/auth/google

Then go here to see userid.
localhost:5000/api/current_user

Order of execution

1. Hit http://localhost:5000/auth/google

passport.js
    passport.use()
        EXISTING-USER: { _id: 5a344062d0f94726d34da9ef,
        googleId: '103507278511115330517',
        __v: 0 }
        SERIALIZEUSER: { _id: 5a344062d0f94726d34da9ef,
        googleId: '103507278511115330517',
        __v: 0 }
        DESERIALIZEUSER: { _id: 5a344062d0f94726d34da9ef,
        googleId: '103507278511115330517',
        __v: 0 }

2. Hit localhost:5000/api/current_user

authroute.js
    req.user: { _id: 5a344062d0f94726d34da9ef,
    googleId: '103507278511115330517',
    __v: 0 }

-----Logging Out Users-----

authroutes.js
    app.get('/api/logout', (req, res) => {
        req.logout(); // Kills user's id in cookie basically makes it to where you no longer are that user.
        res.send(`Logging out: ${req.user}`); // Send to user proof they are no longer signed in.
    });

3. Test logout
Hit localhost:5000/api/logout and you should see a blank screen or it could load with just null.

4. Test if user is logged in.
Hit localhost:5000/api/current_user and you should see a blank screen since req.user has been killed.
Thus res.send(req.user) should push blank output.

-----[Optional] A Deeper Dive-----

app.use() is middleware.
They can execute on incoming requests before they are sent to route handlers.
Every app.use() function you see is its own middleware.

cookie-session stores all the data directly in the cookie. In other words 'Cookie is the session.'
    - Limited to 14KB of stuffing data into the cookie session. A userid is well below limit.
    - You dont' have to use 'Compatible Session Stores' like that in express-session.
express-session stores a reference that ponits to the data at a remote server. In other words 'Cookie references a session.'
    - Advantage is that it can store a lot of remote session data.
