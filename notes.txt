https://github.com/StephenGrider/FullstackReactCode
https://mlab.com/login/

Download most up to data node version.
https://nodejs.org/en/download/current/

Also, install npm version of at least 5.5.

Stripe test credit card#  4242 4242 4242 4242

-----Heroku Deployment Checklist-----

1) Dynamic Port Binding.

server/index.js
    const PORT = process.env.PORT || 5000;

2) Tell Heroku which nodejs version to use. By default, Heroku will try to use an old version of node, which will likely crash the app.

Video uses "node": "8.1.1", "npm": "5.0.3", but i'm using newer version.

server/package.json
    "engines": {
        "node": "8.9.1",
        "npm": "5.5.1" 
    }

3) Tell Heroku to startup nodejs server via start script.

From "sripts" remove "test": "echo \"Error: no test specified\" && exit 1" and add this.

"scripts": {
    "start": "node index.js"
  }

4) We dont want give Heroku our dependencies. We let Heroku decide installing those.

.gitignore
    node_modules


-----Verifying Heroku Deployment-----

jairomh@ubuntu64-DevOps:~/REACTfullStack/server$ heroku create
Creating app... done, ⬢ aqueous-earth-73690
https://aqueous-earth-73690.herokuapp.com/ | https://git.heroku.com/aqueous-earth-73690.git


-----Overview of Passport JS-----

Passport will not do this well.
    Automates vast majority of the OAUTH flow but not the entire things.
    Passport library structure is composed of 2 libraries.
        passport(core that is always installed by you):
            General helpers for handling auth in Express apps.
        passport strategy(requires installing at least one of these):
            Helpers for authentication with on very specific method(email/password, Google, Facebook, etc.).
            If you want to have Google, Facebook, Twitter authentication then you need to install one passport strategy for each one.

-----Passport Setup-----

server$ npm install --save passport passport-google-oauth20

-----Enabling Google OAUTH API-----

Go here https://console.developers.google.com
Click on Add API and search for Google+ API since it contains OAUTH. 
Enable it. Create credentials. Click Oauth client ID.

Oauth clientID:  [check keys.js]
    This is public token and accessible to outside world that identifies application to Google server(s).
client secret:  [check keys.js`]
    Do not share this with anyone.

How to securely store your secret(text value) if you push it to Github?
    Create config/keys.js and in the keys.
    Add keys.js to .gitignore

        Oauth clientID = googleClientID (capital D is important)
        client secret = googleClientSecret

        Notice how we prepend with 'google' to decipher between other Oauth providers like Facebook.

-----Authorized redirected URIs-----

This URI is entirely security related so users dont get tricked by sending their flow over to some hacker.com

    redirect_uri=http%3A%2F%2Flocalhost%3A5000%2Fauth%2Fgoogle%2Fcallback&

Google will return this page at the start of all this auth setp so click on it.

    Visit https://console.developers.google.com/apis/credentials/oauthclient/864190731953-egqj70f75jtofjs2fvsbi2136ip7p72u.apps.googleusercontent.com?project=864190731953 to update the authorized redirect URIs.

    Then under 'Authorized redirect URIs' change http://localhost:5000/* to http://localhost:5000/auth/google/callback

-----OAuth Callbacks-----

Now try to hit http://localhost:5000/auth/google/. It will load a page with 'Cannot GET /auth/google/callback'
It will also load this in the browser URL bar. See it had the code!!!
    http://localhost:5000/auth/google/callback?code=4/fGudjAYLVSl3swMg2FEUufDV0YcrtNZcpv6sx-CiPHQ#

Hit http://localhost:5000/auth/google/ a second time to see our callback be told to execute.

    (accessToken) => { 
    console.log(accessToken);

-----Access and Refresh Tokens-----

-----Nodemon setup-----
REACTfullStack/server$ npm install --save nodemon

Append this to "scripts" section in package.json.
    
    dev": "nodemon index.js"

-----HTTP is Stateless-----

Ajax requests are still HTTP requests. HTTP is stateless.
Server gives us back a token. This token is used as proof by client to tell Server that it already
knows who the client is and the request is safe, since it has record of such token.

OAUTH will use cookie based authentication.

Header inside HTTP packet from Google server will have property 'Set-Cookie', which will hold
the token that will uniquely identify user.
The browser will strip off the token and store it in browser's memory.
Browser will then append that cookie to follow-up requests.
The REACT side of things knows nothing about the cookie authentication, which is great because
the browser will manage this all for us.

Cookie based approach does have shortcomings.
For example, different strategies like JSON web tokens(talk about it later).

-----Signing In Users with Oauth-----

For regular email/password login recognizing the user when they log in is straighforward.
But with Oauth for Google you have to use user's google Id because it will never change. over time.

    profile: { id: '103507278511115330517'

    Because we are placing out trust in Google if Google decides to change the id we are screwed.
    That's how Oauth works so we are making the ASSUMPTION the googleId will not change.
    As far as Oauth all we really care to know is just the Google Id.

-----Introduction to MongoDB-----

SQL                                               | NoSQL
==================================================|===============================================================
Table                                             | Collection(Array of objects(aka Document(s)))
Row/Record                                        | Document
Schema based(columns, column guaranteed to exist) | Schemaless(mix of fields, which is good for data mining)
column                                            | field

-----MonogDB Steup-----

Remote ohsthing of mongoDB is a lot easier then local hosting of it.
DBname: emaily-dev
    DBusername: <see config/key.js>
    DBpassword: <see config/key.js>

-----Connecting Mongoose to MongoDB(remote)-----

If you see or NOT see this warning it's fine. 

~/REACTfullStack/server$ node index.js 
(node:5297) DeprecationWarning: `open()` is deprecated in mongoose >= 4.11.0, use `openUri()` instead, or set the `useMongoClient` option if using `connect()` or `createConnection()`. See http://mongoosejs.com/docs/connections.html#use-mongo-client
Db.prototype.authenticate method will no longer be available in the next major release 3.x as MongoDB 3.6 will only allow auth against users in the admin db and will no longer allow multiple credentials on a socket. Please authenticate using MongoClient.connect with auth credentials.

Just shows how mongoose is interacting with mongoDB.
Until mongoose fixes this there's nothing we can do so get used to them and keep giong.

-----Mongoose Model Classes-----

Don't put models in index.js since that file is more for loading and booting up are app.
Shifting thoughts to mongoDB(not mongoose). MongoDB can have variant amounts of properties(fields) per record(row).
However, mongoose will kinda remove the variant and enforce a Schema.

-----Saving Model Instances(CREATES USER ON REMOTE MONGODB)-----

When is it an appropriate time to create this new user??

DO NOT export model class from User.js and import into passport.js because it will really mess
up future tests with mocha, jest, etc. This will cause you to create copies of the same user
model, which those testing frameworks will yell at. To resolve this do this.
Create model class in passport.js like this.

    passpost.js
        // !TIP:  1 arg means we are fetching out of mongoose.
        // 2 args means we are loading into mongoose.
        // This is our true model Class.
        const User = mongoose.model('users'); 

And leave this as is in User.js

    User.js
        // !TIP:  1 arg means we are fetching out of mongoose.
        // 2 args means we are loading into mongoose.
        mongoose.model('users', userSchema); // Again this loads schema into mongoose.

-----Mongoose Queries-----

serializeUser function is going to be called by passport with our user model that we fetch in the first login step.
Refer to 'fist login step' diagram in notes.txt.
We are going to use that user model as our identifying piece of user information.
This info will be passed back to passport.
Passport will stuff cookie into token and send token to user.

deserializeUser function will be called by passport when a user client with its cookie makes a request to our server.
A request such as 'Can I have a list of my posts?'.
deserializeUser function will turn cookie into unique user model that identifies user.
The user is the passed into passport telling passport the user is real and authenticated so let's give user their list
of posts that belong to them.

-----Deserialize Cookies-----

-----Enabling Cookies-----

Out of the box express has no idea how to handle cookies.
To manage cookies in our app.

~/REACTfullStack/server$ npm install --save cookie-session

Then add them into

    passport.js
        const cookieSession = require('cookie-session'); // Give access to cookies.
        const passport = require('passport'); // Makes use of cookies.

and into

    index.js
        app.use(
            cookieSession({
        app.use(passport.initialize());
        app.use(passport.session());

-----Testing Authentication-----

    authroutes.js
        req.user is short for request.user.

            app.get('/api/current_user', (req, res) => {
                res.send(req.user);
            });

To see if you're getting your cookie go to here again.
http://localhost:5000/auth/google

Then go here to see userid.
localhost:5000/api/current_user

Order of execution

1. Hit http://localhost:5000/auth/google

passport.js
    passport.use()
        EXISTING-USER: { _id: 5a344062d0f94726d34da9ef,
        googleId: '103507278511115330517',
        __v: 0 }
        SERIALIZEUSER: { _id: 5a344062d0f94726d34da9ef,
        googleId: '103507278511115330517',
        __v: 0 }
        DESERIALIZEUSER: { _id: 5a344062d0f94726d34da9ef,
        googleId: '103507278511115330517',
        __v: 0 }

2. Hit localhost:5000/api/current_user

authroute.js
    req.user: { _id: 5a344062d0f94726d34da9ef,
    googleId: '103507278511115330517',
    __v: 0 }

-----Logging Out Users-----

authroutes.js
    app.get('/api/logout', (req, res) => {
        req.logout(); // Kills user's id in cookie basically makes it to where you no longer are that user.
        res.send(`Logging out: ${req.user}`); // Send to user proof they are no longer signed in.
    });

3. Test logout
Hit localhost:5000/api/logout and you should see a blank screen or it could load with just null.

4. Test if user is logged in.
Hit localhost:5000/api/current_user and you should see a blank screen since req.user has been killed.
Thus res.send(req.user) should push blank output.

-----[Optional] A Deeper Dive-----

app.use() is middleware.
They can execute on incoming requests before they are sent to route handlers.
Every app.use() function you see is its own middleware.

cookie-session stores all the data directly in the cookie. In other words 'Cookie is the session.'
    - Limited to 14KB of stuffing data into the cookie session. A userid is well below limit.
    - You dont' have to use 'Compatible Session Stores' like that in express-session.
express-session stores a reference that ponits to the data at a remote server. In other words 'Cookie references a session.'
    - Advantage is that it can store a lot of remote session data.

-----Dev vs Product Keys-----

Curently we have one set of keys in config/keys.js.
Best to do two separate sets of keys.
Production keys will be stored on Heroku and Dev keys will be on your machine.

    -----Generating Production Resources-----

1. Setup production mongoDB by creating.

    DB username: jairoprod; passwd: password

2. Setup production version of Google API. Remember, we have to go to console.developers.google.com

    - Create a new separate project to isolate away from emaily-dev and called it emaily-prod.
    - Select Google+ to create Oauth 2.0 API. 
    - Then click create credentials to make OAuth client ID.
        Configure product anme on Consent Screen before moving forward. 
        This is where you can put URL and logo if you were doing thi at a real job.
        At least fil in 'Product name' as Emaily. It makes no sense to put in Emaily-prod since this is what users will see.
        It is just to tell users who they are granting access too.

    ----Heroku Env Variables-----

Under Heroku app SETTINGS clikc 'Reveal Config Vars' and put ke/value:
    GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, MONGO_URI, COOKIE_KEY

    When creating COOKIE_KEY in HEROku type in a long random one of letters and numbers.
    MONGO_URI is mongodb://jairoprod:password@ds063134.mlab.com:63134/emaily-prod

After you deploy to git and then git heroku go there to start Oauth flow

    https://aqueous-earth-73690.herokuapp.com/auth/google

you should get 400 Error: redirect_uri_mismatch.'

    ----Fixing Heroku Proxy Issues-----

Cause of the 400 Error: redirect_uri_mismatch.' is because google is redirecting using http when inside the console.developer
api we speicified https.

    Choose your fix preference. Both are easy but option 2 is easier.

    1. Inside passport.js one can put the full URL path by adding say key

        googleRedirectURI: 'https://aqueous-earth-73690.herokuapp.com/auth/google'

        in prod.js and substituing the key into callbackURL in passport.js.

        callbackURL: '/auth/google/callback'

    2. Add proxy: true into passport.js.

Close browser and reload https://aqueous-earth-73690.herokuapp.com/auth/google.
You should now get this to show it's working.

    Cannot GET /auth/google/callback

And this should be working too.
    https://aqueous-earth-73690.herokuapp.com/api/current_user
    
    {
        _id: "5a42b00eda6c8800146b52a8",
        googleId: "103507278511115330517",
        __v: 0
    }

----React App Generation-----

Google 'create react app' to download popular tool for building React apps.
    https://github.com/facebookincubator/create-react-app

Install tool as global npm module to then generate a new React project.
~/REACTfullStack/server$ npm install -g create-react-app

Now Generate React project.
~/REACTfullStack/server$ create-react-app client

----A separate Front End Server-----

client folder has its own built-in server!!

~/REACTfullStack/server$ cd client/
~/REACTfullStack/server/client$ ls
node_modules  package.json  package-lock.json  public  README.md  src

In order to run the React side you have to be in client folder to run npm start.
~/REACTfullStack/server/client$ npm start

    Compiled successfully!

    You can now view client in the browser.

    Local:            http://localhost:3000/
    On Your Network:  http://192.168.1.72:3000/

    Note that the development build is not optimized.
    To create a production build, use npm run build.

This will also open the React browser page.

WHY USE create-react-app TOOL AND NOT JUST STICK WITH EXPRESS SERVER TO BUILD REACT PORTION??
    ANSWER: It's a little hard to do it with EXPRESS but you can, but create-react-app has so much
    prebuilt configuration that will save us so much time trying to wire webpack/babel/devServer.
    All this stuff we get out of the box for free. It allows React server and EXPRESS server work 
    together nicely.

----Running the Client and Server----

To run the REACT client server add this script to server/package.json. The flag --prefix executes client server from 'client' folder.

    server/package.json
        "client": "npm run start --prefix client"

THIS IS NOT NECESSARY SINCE YOU CAN STILL RUN EACH SERVER IN A SEPARATE CLI SESSOIN, BUT IT'S HANDY.

Now combine both "dev" and "client" scripts.
First, change "dev" to "server" to keep names functional consitent.
Then add new "dev" script to start both "server" and "client" concurrently.

    server/package.json
        "dev": "concurrently \"npm run server\" \"npm run client\""

Finally install concurrently as npm module.

----Routing Stumbling Block----

~/REACTfullStack/server$ npm install --save concurrently

This is naive because this href attribute implies relative domain path

    <a href="/auth/google">Sign In With Google</a>
    
which points to http://localhost:3000/auth/google

but how do you get it to know to route to local dev vs. remote heroku.
Solution is to add this to client/src/packgae.json

    "proxy": {
        "/auth/google": {
        "target": "http://localhost:5000"
        }
    },

When clicking on our React home page the 'Sign In with Google' link should takes us back to the 
Google 400 Error: redirect_uri_mismatch which means we are now hitting our Oauth Flow.

----The Beauty of Create React App's Proxy----

On our DEV side both the create-react-server and Express server handle requests.
Front-end requests are hanled by create-react-server and backend request by Express server.
On Heroku Express hanldes both.

Only add this to the DEV side since we can allow for lesser security.
Click on link shown on the Google 400 Error: redirect_uri_mismatch webpage.

https://console.developers.google.com/apis/credentials/oauthclient/864190731953-egqj70f75jtofjs2fvsbi2136ip7p72u.apps.googleusercontent.com?project=864190731953

Then add port 3000 into 'Authorized redirect URIs' field on your console.developers page.

http://localhost:3000/auth/google/callback

THE CHANGE TAKES A MINUTE OR TWO TO UPDATE THE CHANGES TO OTHER GOOGLE SERVERS.

Now you should be able to hit port 3000 Oauth flow with http://localhost:3000/auth/google, which loads page:
    Cannot GET /auth/google/callback

FOR PRODUCTION when webpack and babel builds the production file inside your DEV create-react-app it will auto-configure 
the missing proxy for production for you and place it into client/build folder...build folder is created after running
'npm run build'.

    client/package.json.
    "proxy": {
        "/auth/google": {
        "target": "http://localhost:5000" <-- THIS WILL BE REPLACED IN PRODUCTION. ONLY REQUIRED FOR DEV.

You can quickly do a test to create your React app with 'npm run build' it will show this message.

    $ cd client; npm run build;
    
    Creating an optimized production build...

IMPORTANT POINT!!
    The reason this all works in both DEV and PROD is because the browser already prepends the 
    base URL domain to your href link so we dont need any crazy routes.

    client/src/App.js
        <!-- TRANSLATES TO href="http://localhost:5000/auth/google" WHEN IN DEV OR FULL HEROKU LINK WHEN IN PROD. -->
        <a href="/auth/google">Sign In With Google</a> 

    ---[Optional] Why This Architecture?--- (SEE DIAGRAM)

---Frontend Tech-----------------------------------------------

Delete these boilerplate files except for registerServiceWorker.js.

~/REACTfullStack/server$ ls -lh client/src/
total 28K
-rw-rw-r-- 1 jairomh jairomh  377 Dec 26 14:45 App.css
-rw-rw-r-- 1 jairomh jairomh  588 Dec 26 16:52 App.js
-rw-rw-r-- 1 jairomh jairomh  208 Dec 26 14:45 App.test.js
-rw-rw-r-- 1 jairomh jairomh   63 Dec 26 14:45 index.css
-rw-rw-r-- 1 jairomh jairomh  254 Dec 26 14:45 index.js
-rw-rw-r-- 1 jairomh jairomh 2.7K Dec 26 14:45 logo.svg
-rw-rw-r-- 1 jairomh jairomh 4.0K Dec 26 14:45 registerServiceWorker.js <-- KEEP THIS ONE

See Digrams.
    client/src/index.js -- DATA LAYER CONTROL(REDUX)
    client/src/App.js -- RENDERING LAYER CONTROL(React Router)

Under client side install react packages.
    ~/REACTfullStack/server/client$ npm install --save redux react-redux react-router-dom

Create blank index.js under client/src.

If .js file starts with a capital letter then it's exporting class based component.
If if starts with lower case then the file is exporting a function component.
Note:  Use of 'import' keyword is supported since frontend makes use of Babel/Webpack.

client/src/public/index.html houses React side of our app.

---Troubelshooting NPM--

If you see this error

    events.js:183
      throw er; // Unhandled 'error' event
      ^
      .....
    npm ERR! code ELIFECYCLE
    npm ERR! errno 1
    npm ERR! client@0.1.0 start: `react-scripts start`
    npm ERR! Exit status 1

simply delete package-lock.jsom from client/ folder and cd into it then run 'npm install'.
If that does not work run 'npm install' and 'npm update' and reboot.

---Redux Review and Setup---(SEE DIAGRAM)

Redux store is where all our state exists.
To determine state or to change it call an action creator to dispatch(aka returns) actions.
Action is sent to reducer(s).
Those reducers are combined together with combineReducers call, which updates state in our redux store.

Remember, Provider component from React-Redux library is the bonding glue between reacd and redux.
It's placed at the very parent component of our app so any sub-components(no matter how nested) 
now access that GLOBAL state. The Provider component monitors for state changes in Redux store the
Provider will inform all of its children components of the new state and update those components
with the new state.

After configure provider be sure to test your "Hi there!" webapge is still loading.

    client/src/index.js
        <Provider store={store}><App/></Provider>

---The Auth Reducer---

After making client/src/reducers/authReducers.js and it's matching index.js test "Hi there!"
webpage is still loading.

---Why We Care About Auth---

Main login page Header component will change in some fashion when user logs in to say we're logged in.

    React Router Setup---

A route is a pairing between the URL address a user is looking at and the components shared on the screen.
Routes will be placed in App.js. Remember index.js is our top-level for Redux state data setup.

App.js
    // BrowserRouter is the brains of react-router and tells it how to behave. It looks at current URL
    // and changes set of components visible on the screen.
    // Route component sets up a rule between user visited route and visible set of components.
    import { BrowserRouter, Route } from 'react-router-dom';

GOTCHA: BrowserRouter component can at most just have one child. For example, each <div><div/> represents 
a child so have two like this will produce an error.

    <BrowserRouter>
        <div><div/> -- 2 div's produce error.
        <div><div/>  
    </BrowserRouter>

Assuming user went to top path URL emaily.com then REACT root path of app would be /.

    <Route path="/" component={Landing} />

---Always Visible Components---

Routes are "reverse" greedy matched meaning localhost:3000/ only matches
    <Route path="/" component={Landing} />

but localhost:3000/surveys matches both
    <Route path="/" component={Landing} />
    <Route path="/surveys" component={Dashboard} />

trick is to use 'exact' property on "/"
    <Route exact path="/" component={Landing} /> -- BY DEFAULT 'exact' is same as writing 'exact={true}'

---Materialize CSS---

http://materializecss.com/

cd into client folder
~/REACTfullStack/server/client$ npm install --save materialize-css

---Webpack with CSS---

When we installed create-react-app' it came with Webpack.
Webpack can also import CSS files and include it in its bundled files.
You could put the import statement in client/src/index.js or App.js. It's your preference
on how its placement makes sense to you.
Since this is not .js file you have to specifiy .css extension and webpack knows to look in npm 
folder since we did not specify a './' at the beginning of the path.

client/src/index.js 
    import 'materialize-css/dist/materialize.min.css';

---Current User API---

When our app boots up this will determine if a user is signed in.
If it returs none then we know we are not logged in.

authroutes.js
    app.get('/api/current_user', (req, res) => {

To do this we make an ajax request from the React client side.

---Additional Proxy Rules---

Install axios so client side can make ajax requests to our backend API and redux-thunk 
to make asynchronous action creators behave the way we expect.

~/REACTfullStack/server/client$ pwd
/home/jairomh/REACTfullStack/server/client
~/REACTfullStack/server/client$ npm install --save axios redux-thunk

client/src/actions/index.js

    const fetchUser = () => {
        // Only needs relative path, which goes back to long discussion about 
        // how root URL is prepended in both DEV and PROD environment.
        axios.get('/api/current_user')
    };

Then be sure to add proxy rule in client/package.json.
    "/api/*"

---Basics of Redux Thunk(SEE DIAGRAM)---

Idea behind redux-thunk is that it breaks the rule an action creator needs to immediately
return and action. With redux-thunk it doesnt have to be immediate.

With help of redux-thunk it allows us to dispatch action only when axios get promise request has been resolved.

---Testing fetchUser---

Add this line

    authReducer.js
        console.log('ACTION:', action);

to test if fetchUser action creator is dispatching reducer after setting redux-thunk and redux.

    client/src/components/App.js
        componentDidMount() {
            // tied in with connect() below to allow seeing fetchUser from actions/index.js
            this.props.fetchUser(); 
        }

        // 1st is map-state-to-prop function <-- null
        // 2nd options is action creator(s) being passed
        // 'actions' is now assigned to App component as props
        // thus are accessible with this.props.
        export default connect(null, actions)(App); 

---AuthReducer Return Values---
---Accessing State in the Header---

Remember how to hook a Component to the redux store.
    Import connect helper from react-redux.
    Define map-state-to-props function
    Pull out pieces of state we care about into the component.

Login: http://localhost:3000/auth/google
CurrentUser: http://localhost:3000/api/current_user
Logout: http://localhost:3000/api/logout

---Header Content---

Switch stamement to decide what login state to show in Header.

---Redirecting a User on Auth---

Added redirect to our api server/index.js file to get rid of 'Cannot GET /auth/google/callback' 
webpage error.

---Redirect on Logout---

Which one to choose?
    Traditional -- Let Browser do entire browser refresh to kick user out.(WE'LL CHOOSE THIS ONE)
    AJAX Request -- No page, refresh, but have to handle to ation creators, reducer, etc,
        and redirect to landing page. Much faster process.

---Landing Component---

---Link Tags---

<a> tags are used if you are leaving that page to a different domain like our oauth flow.
But to navigate around our app use the Reat <Link> tag instead.

    client/components/Header.js
        <Link 
            className="left-brand-logo" 
            to={this.props.auth ? '/surveys' : '/'}

---Handling Payments-----------------------------------------------
---Client Side Billing---
---Billing Considerations---

Rules of Billing
    We are Bad at security
        Never have our backend server accept credit cards
        Never store credit card numbersAlways use an outside payment processor.
            I recommend using 'Stripe' vendor payment processor for all future projects.

    Billing is hard
        Possible to avoid montly payments/multiple plans?
        Fraud and chargebacks are a pain.
    
---Stripe Billing Process---

Stripe will show a credit card form for us.
We will not interact with the credit card number during the payment process.
When Stripe returns a token think of it as a "pending charge" or "authoriztion".
The user has authorized your application to charge up to some dollars to their credit card.
This token is then given to our API to confirm the charge and add credits to user account.

---Exploring The Stripe API---

Goto stripe.com and setup account.
Click 'API' on the left side menu and get Publishable key.
To be clear server/config/ is to be used by our backend. 
Keys setup for frontend with Stripe is different.

Go get the paying form here --> https://stripe.com/checkout
'Checkout' is a JS library, which works well with JQuery or AngularJS, but you can still do 
it with React but it wont be as easy.
Instead use 'react-stripe-checkout' component from Github.

    ~/REACTfullStack/server/client$ npm install --save react-stripe-checkout

---Stripe API Keys---

Publishable key is required on frontend of app.
Backend wants both the Publishable key and Secret key.

---Env Variables With React---

Google 'create-react-app environment variables' and click on it.
Scroll down and click 'Adding Custom Environment Variables'.

Custom environment variables that we create must begin with 'REACT_APP_'.
This prevents exposing a private key on our machine.

Create client/.env.development and client/.env.production and add this in there.

    REACT_APP_STRIPE_KEY=pk_test_vgSiBlGWBniU5MssbhfeX8J8

INstructor recommends adding these two files to .gitignore.

---The Payments Component---

By default StripeCheckout will default to U.S. dollars.
    
    client/components/src/Payments.js

            <StripeCheckout 
                amount={500}
                token={token => console.log(token)} <-- callback function that runs when receive the token from Stripe.
                stripeKey={}
            />

---Stripe Tokens---

Check out video to see token returned from Stripe in the form of an object.
It shows you key/values used by fraud dectection agencies. There is also a 'card'
property that contains info about the entered credit card like 'Visa', 'zip code', 'exp_month', 'exp_year', 'address_city', etc.

---Payment Fixes---

Box in diagram labeled 'Add credits to user's acount' is not really a user account per se.
We have an object model inside our DB that represents a user. Every user model will have 
a record of number of credits it owns.

To customize the popup pay window add these properties.

    client/src/components/Payments.js
        <StripeCheckout 
            name="Emaily"
            description="$5 for 5 email credits"
            amount={500}
            token={token => console.log(token)}
            stripeKey={process.env.REACT_APP_STRIPE_KEY}
        />

---Reusing Action Types---

We are now ready to use token received from Stripe and send to our Express server, which will be responsible for
following up with STripe.

Remember the auth reducer stores the user model, which will be used to update how many credits to display.

---Positing The Stripe Token---
---Pos Request Handlers---

---Creating Charges---

Load backend npm module, which is a separate backend Stripe library, to help us work with 
Stripe API. This take the token we got from the frontend and exchanges it for an actual
charge to the user's credit card.

Search on npm repo for npm Stripe library https://www.npmjs.com/package/stripe
Click on Stripe API to find the 'charge object' https://stripe.com/docs/api/node#intro
Then go to 'Create a charge' page.

Key 'source':  
    It is what credit card or what source of payment being used.
    It is the token we got back from Checkout.js library. 
    It returns us an authorization to say 'you are authorized to charge up to 5 dollars 
    on this card" so you refer to it as a source of money or credit.

REACTfullStack/server$ npm install --save stripe

---BodyParse MiddleWare---

HUGE GOTCHA with Express server. When you make a POST request to an Express server.
Express by default does not parse the Express payload so we have to install a module
to take the request body parse it and then make it available to everything inside our 
application. The module is body-parser.

Definition:
    Parse incoming request bodies in a middleware before your handlers, available 
    under the req.body property.

---Creating a Charge Object---

If one does not use bodyParser along with app.use(bodyParser.json()) then you will 
get this error.

/server/routes/billingRoutes.js
    [0] req.body: undefined

    Instead of this 

    [0] req.body: { id: 'tok_1BiliEJrjGg58L4fJWnhxqWX',
    [0]   object: 'token',
    [0]   card: 
    [0]    { id: 'card_1BiliEJrjGg58L4f7mWtryMe',
    [0]      object: 'card',
    [0]      address_city: null,
    [0]      address_country: null,
    .....
    [0]      address_zip_check: null,
    [0]      brand: 'Visa',
    [0]      country: 'US',
    [0]      cvc_check: 'pass',
    [0]      dynamic_last4: null,
    [0]      exp_month: 10,
    [0]      exp_year: 2020,
    [0]      funding: 'credit',
    [0]      last4: '4242',
    [0]      name: 'joe@joe.com',
    [0]      tokenization_method: null },
    [0]   client_ip: '107.193.207.36',
    [0]   created: 1515598918,
    [0]   email: 'joe@joe.com',
    [0]   livemode: false, <--- MEANING TEST MODE
    [0]   type: 'card',
    [0]   used: false }

Fill in stripe.charges() under app.post().

---Finalizing a charge---

When something is ayncrhonous you can choose from using one of these 3:
    - callback function
    - promise
    - new async syntax.

If you look at the npm documentions for stripe it recommends using promise.
But aync syntax uses promises we'll use it in the refactor.

server/routes/billingRoutes.js
    // REFACTOR async
        app.post('/api/stripe', async (req, res) => {

            console.log('req.body:', req.body);
            // Confirm the charge on the backend. Different than the authorization initiated by frontend.
            const charge = await stripe.charges.create({    
            ....
        }
        console.log('charge:', charge);

    Here is the charge!

        charge: { id: 'ch_1BiqhPJrjGg58L4fUwB4WO7G',
        [0]   object: 'charge',
        [0]   amount: 500,
        [0]   amount_refunded: 0,
        [0]   application: null,
        [0]   application_fee: null,
        [0]   balance_transaction: 'txn_1BiqhPJrjGg58L4fXN2QNZ3i',
        [0]   captured: true,
        [0]   created: 1515618087,
        [0]   currency: 'usd',
        [0]   customer: null,
        [0]   description: '$5 dollars for 5 credits',
        .....

---Adding Credits to a User---

Credits by default should be 0 and you need to tell the credits key it needs to be of type number.

models/User.js
    credits: { type: Number, default: 0 }

There's more variety of options you can pass to a property so check mongoose to see such options.
Recall that whenever making using of passport and user has signed into app we can access current 
usermodel as req.user.

    // After successfully applying charge to user's credit card update usermodel  
    // with $5 credit and then send usermodel back to client.
    req.user.credits += 5;
    const user = await req.user.save(); // BEST to have a copy of the usermodel returned back to 
                                        // us since it will always hold its latest copy.
    res.send(user); // Send requested data from usermodel DB to browser.

---Requiring Authnetication---

We need to figure out a way to use this in many other routes to secure our App by making
sure a user is logged in to perform any actions. Basically do a DRY(DonotRepeatYourself)

models/User.js
        if (!req.user) { // user does not exist or not logged in.
            return res.status(401).send({ error: 'You must log in!' }); // 401 Forbidden from accessing resource.
        }
    ---Route-Specific Middlewares---

Create new middleware to test user is logged in.
Middleware only to be used by request handlers(routes) that require authentication.
Create folder server/middlewares.

Express does not care how many functions you toss in here Like requireLogin, acaxx, async(req, res), etc.

    server/routes/billingRoutes.js
    app.post('/api/stripe', requireLogin, async (req, res) => {

Express only requires that one of these functions MUST send something back as a response as req.send.

---Displaying Credit Quantity---

Header.js already contains 'credits' value the moment user logs in via this.props.auth so you acccess 
them this.props.auth.credits.

---Updating Credits---

Review:  When 'tokens' in Network bar in Chrome that's Stripe getting token. And 'stripe' then updates 
the credits to our backend usermodel and retrieves the usermodel credit value to the browser.

---Back End to Front End Routing in Production-----------------------------------------------
---Express with Create-React-App in Production---

Two BIG topics.
    How our server(express) changes between production vs dev.
    Build process on client side of our app.

Review diagrams under section "The Beauty of Create React App’s Proxy".

Remember npm run build generates the static files that will be served up to users in production.
    build/static/js/main.xxxx.js
    build/static/css/main.xxxx.js

The point here is that there are routes handled by Express server like /api/stripe.
And there are routes handled by react-router like /surveys or /client/build/static/js/main.js.

---Routing in Production---

Add some code to have Express behave correctly when in production environment.

server/index.js
    if (process.env.NODE_ENV === 'production') {
        // Order of operations matter here.

        // Express will serve up production assets 
        // like our main.js file or main.css file.
        app.use(express.static('client/build')); // If any GET request comes in looking for /client/build/static/js/main.js 
                                                // then just look in 'client/build' since it lives in that request path.

        // Express will serve up the index.html file if it doesnt recognize the route. 
        // This is catch-all if there's no match for 'client/build'.
        const path = require('path')   ;
        app.get('*', (req,res) => {
            res.sendFile(path.resolve(__dirname, 'client', 'build', 'index.html'));
        });
    }

---Deployment Options---

Executing build. See digram. We are breaking convention if we go with Option 1 because 'create-react-app' gitignores 
the build folder. This option also builds code locally.

These follow Convention that you will NOT commit your build project:

Option 2 pushes to Heroku and has Heroku do the build with dependencies. This is not bad per se but this is where some
developer supersition you might have bad luck comes in. This is because Heroku has to install ALL(I mean ALL) dependencies
like Webpack and Babel or piices of 'create-react-app'. These are all used for development so why would you install those
on production!? Answer is it doesnt matter since Heroku will not use them(laod into memory) in build process even though 
Heroku sees them.

Option 3 pushes to CI by making use of 3rd party server to build app. Take all your files(both React/Express) commit to Git
and pushes it off to CI(Continous Inegration) to run tests on your code. Once tests pass then install all client dependencies,
build the project, commit it to say a different deploment branch on Git. Then push build off to Heroku.

We are going with Option 2.

---Adding in a Heroku Build Step---

+ Push to Heroku 
+ Heroku installs server dependencies 

We tell Heroku that it needs to install all our dependencies(server/client/development).
And that it needs to run 'npm run build' within project.

+ Heroku runs script 'heroku-postbuild' 
+ We tell Heroku to install client deps 
+ We tell Heroku to run 'npm run build'

Watch video to customize build process from Heroku website using "postintall" package.json key,
which is automatically detected by Heroku.

    "scripts": {
        "postinstall": "bower install && grunt build"

bower is a client-side JS dependency system.
grunt is a task runner unlike webpack.
FYI we are not using these. Just an example on Heroku site.

Heroku also has Heroku-specific build steps.
For our project, we will need to buld production assets after dependencies are installed using "heroku-postbuild".
This ensures we only build the project on Heroku and not local machine.

    server/package.json
        "scripts": {
                "heroku-postbuild": "echo This runs afterwards."

NOte this out of order in the list, but this is how we tell Heroku to install client dependencies.
Scroll to devDependencies this will install dev dependencies on heroku by setting it to false.
    
    $ heroku config:set NPM_CONFIG_PRODUCTION=false

This means anytime you install npm modules they will install both production and development modules
on Heroku. Even though this is a global setting we will need to make sure it only affects our client 
side and not server side by using --prefix flag. Remember Heroku only cares about the package.json in the server/ folder.

    server/package.json
        "heroku-postbuild": "NPM_CONFIG_PRODUCTION=false npm install --prefix client && npm run build --prefix client"  <-- TELLS HEROKU TO INSTALL BOTH PRODUCTION AND DEVELOPEMENT DEPENDENCY MODULES.


jairomh@ubuntu64-DevOps:~/WORK/REACTfullStack/server$ git commit -m'Added billing and client side app!' 
jairomh@ubuntu64-DevOps:~/WORK/REACTfullStack/server$ git push
jairomh@ubuntu64-DevOps:~/WORK/REACTfullStack/server$ git push heroku master
jairomh@ubuntu64-DevOps:~/WORK/REACTfullStack/server$ heroku open

On production Heroku had to add this config variable to Heroku app's settings dashboard to fix 
"You did not set a valid publishable key. Call Stripe.setPublishableKey()."

    REACT_APP_STRIPE_KEY with value pk_test_vgSiBlGWBniU5MssbhfeX8J8.

Remember to add a comment to any file(I chose notes.txt) so that git push heroku master pushes up your server folder
to Heroku again so that the App now loads in REACT_APP_STRIPE_KEY straight from Heroku.


---Mongoose for Survey Creation!-----------------------------------------------
---Survey Overview---

See diagram for survey flow. Starup/product owners want to solicit feedback from end-users about their product.
Starup/product owners are using our service to send out such survey to end-users.

Fields Subject: and From: and body are customizable.

---Server Routes---

Overall thought process for surveys.
    Persist them in our DB so that someone can go back and revisit them over time.

---Survey Model---

User User.js as a guide to create Survey.js

---Model Deficiencies---

Where do we save survey responses to for the question "Did you like our service"?

How to prevent duplicate responses by same user to a survey?
    Answer: Setup a "subdocument collection" a term used by Mongo/mongoose.
    Inside list of recipients we are going to store little models called "Recipient".
    Each "Recipient" will have a "email" and a boolean "clicked" property.
    We can use these properties to prevent duplicate survey responses from same user.

    ---Limitations of Subdocument Collections---

MongoDB has a limit per document(row) at 4MB limit size.
See video as to why we have to design our Subdocument Collections in our chosen manner.
An email adress is avg size 20 bytes long multiplied by 200,000 = 4MB!!
So this means a single survey can only store up to 200,000 email adresses per indiviaul survey.
This is a reasonable limit.
But if you make just one big User collection that has Survey(s) as an attached child then you would
exceed a memory limit and thus makes it sort of a bug.(see video.)

---Setting up Subdocs---

After creating Recipient schema in models/Recipient.js you have to then go to models/Survey.js and modify
recipients key 

    models/Recipient.js
        recipients: [String] to [RecipientSchema]

---Relationship Fields---

A user will have many surveys so how do know what survey belongs to what user??
    Answer: Setup a relationship between user and survey by adding another property
    to surveySchema.

    models/Survey.js
        _user: { type: Schema.Types.ObjectId, ref: 'User' }

    The ObjectId portion is the id of the user who owns that record.
    Key value ref just means the reference we are making ObjectId to belongs to 
    'User' collection.
    _ is NOT required but by convention makes it obvious it's a relatiosnhip field.

---Survey Creation Route Handler---

Use digram from 'Server Routes' video.
Just like before when setting up routes.

1. Define arrow function and export it.
2. Wire up to Express App object in server/index.js.

First thing to check in routes/suveryRoute.js

    Are you logged in and do you have at least one credit to send out a survey.

Remember the middleware we created can be reused for this purpose.
    routes/surveyRoute.js
        const requireLogin = require('../middlewares/requireLogin')

---Veifying Minimum Credits---

Create middleware/requireCredits.js and slighlty tweak logic and statu code.

    middleware/requireCredits.js
        if (req.user.credits < 1) { // No credits then kick user out.
            return res.status(403).send({ error: 'Not enough credits!' }); // 403 Forbidden.

Then module.exports requireCredits to surveyRoute.js.

---Creating Surveys---

Use digram from 'Server Routes' video.
    route/surveyRoute.js
        // Do this vs. using 'require' out of models/Survey.js because it will be 
        // less of a headache if you decide to use a testing framework in the future.
        const monggoose = require('mongoose');
        const Survey = mongoose.model('surveys');

Complicated tranformation here because we have to transform an array of 
strings(emails) to array of objects.

---Creating Mailers---

See diagram being updated to say that it POST /api/surveys should also send out a 
big email after survey creation. Also, review “Survey Overview” 2nd diagram.
Make sure email is sent successfully before saving the survey.

From diagram the 'Survey Instance' is the data layer and the 'Email Template' is 
the visual look and feel layer. We will merge both into a 'Mailer' object that will 
represent one single email that we want to send out to some number of people. 
Think of 'Mailer' as a helper. Finally we will send it off to an email 3rd party
provider API.

---Identifying Unique Users---

SEE DIGRAMS. Email provider is SendGrid. 
They will know what recipient clicked on the email link.
They know because they map recipients to a secure token.

---Identifying Unique Users---
---Sendgrid Setup---

Signup at sendgrid.com and create API keys under Settings(left menu).
    - API key name = emaily
    - API Key Permissions = Full Access
Stored Sendgrid APIkey in config/dev.js.

Add APIkey at Heroku in the config variables.
Install sendgrid library in our project.

    server$ npm install --save sendgrid

---Mailer Setup---

SEE DIAGRAM.
We will use a lot of helper functions that come from Sendgrid so the code could 
look a little complex. 
Template will inject HTML into email.
from_email will be some default email.

---Mailer in Use---
---Mailer Constructor---

The survey instance uses the subject and recipients property just like the 
digram under "Mailer Setup".

---Boilerplate for Sending Emails---
---More Mailer Properties---
---Sending SendGrid Emails--
---Testing Email Sending---

We CANNOT use POSTMAN to test Sendgrid API because we have middleware(requireLogin, requireCredits.

     server/routes/surveyRoutes.js
        app.post('/api/surveys', requireLogin, requireCredits

It is pain in the neck complicated to do Oauth flow(cookies) by our middleware in POSTMAN.
Instead we should use axios from our REACT front-end. Remember our REACT side will include
auth and cookies so this now creates a "FAKE" REST client.
First, add axios to window object so you can now access it in the Chrome console:

    client/src/index.js
        // Temporary code to test email sending.
        import axios from 'axios';
        window.axios = axios;

    CHROME CONSOLE:
    > axios
        function wrap() {
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; i++) {
                args[i] = arguments[i];
            }
            return fn.apply(thisArg, args);
        }

SUCCESS!! Looks like this --> RESPONSE STATUSCODE: 202

---Improving the Email Template---

By adding in html to services/emailTemplates/surveyTemplate.js

---Polish in the Route Handler---

Make the function in app.post an async for /server/routes/surveyRoutes.js since we need
to wait for the email to be successfully sent before writing to DB.

---Verifying Sendgrid Click Tracking---
---Feedback for User Feedback---
To get Feedback form ready for dev and prod.

server/services/emailTemplates/surveyTemplate.js
    href="http://localhost:3000"
    change to
    href="${keys.redirectDomain}"

We defined the keys in 
    server/config/dev.js
        redirectDomain: 'http://localhost:3000'
    and 
    server/config/prod.js
        redirectDomain: process.env.REDIRECT_DOMAIN

Then to prevent the form from kicking you back to the email app after you answer yes/no
add this

    server/routes/surveyRoutes.js
            app.get('/api/surveys/thanks', (req, res) => {
            res.send('Thanks for voting!');
        });

then go back and change href="${keys.redirectDomain}" in server/services/emailTemplates/surveyTemplate.js
to href="${keys.redirectDomain}/api/surveys/thanks".

A second way of doing this would be just include the redirecDomain in the survey model 
const survey = new Survey() properties in  surveyTemplate.js.

---Back to the Client!-----------------------------------------------
---Client Side Survey Creation---
We can choose one of these for direction of our project:

1. Focus on backend Sendgrid webhook for whenever a user clicks on a button it 
sends feedback to server.
2. Frontend form component for user to create a new survey.

We'll go with 2 and start working on our Dashboard.
Create this file with basic return <div>:

    server/client/src/components/Dahsboard.js

the remove dummy component

    client/src/components/App.js
        const Dashboard = () => <h2>Dashboard</h2>;

---Material Icons---

Go back to materializecss.com and search for the add button(circle with a + sign).
Got Components/Buttons in left side menu.
The button will say "ADD" which is not what we want. Search for 'Icons' at 
matterialcss site(SEE VIDEO).

---Navigation with the Link Tag---
---SurveyNew Form---
SEE DIAGRAM.
Let's review how the Components will be built around the form.

---Purposes of Redux Form---

SEE DIAGRAM for React Component structure.
We could build entire form into a single component, but we would end up with really nasty code.
REMEMBER you can only pass props down to the child components so everytime you update a
SurveyField you would have to communicate up to the closest common parent(SurveyNew) about the 
prop so that it's then pushed down to child SurveyFormReview.

Here comes Redux to the rescue, but specifically use ReduxForm since we're dealing with a 
form here because it will do all the Redux work behind the scenes for you. Like creating 
action creators, reducers(aka formReducer), and wiring up 'connect' to access props, 

For simple forms like type in some data and hit SUBMIT to save it on a server then ReduxForm
is overkill. But our form has multi wizard form that has more than 1 page that can load(SurveyForm
and SurveyFormReview) so using ReduxForm is a lot easier.

---Redux Form Setup---
Install redux-form.

    server$ cd client/
    server/client$ npm install --save redux-form

Goto redux-form.com is among the best documentation ever for any library of any language.
Click on Examples section. Check out Wizard From.
We'll go thru Getting Started guide.

Create client/src/components/surveys/SurveyNew.js

If you have your custom app you have to use the 'form' key you will need to change this 'form' 
key name, but it's pretty rare. Consult FAQs at redux-form.com.

---The ReduxForm Helper---

Leave surveys/SurveyNew.js as simply as possible for now and work on its subcomponents SurveyForm 
and SurveyFormReview next. 

reduxForm is so similar to our 'connect' method used to wire up components to Redux store.

    client/src/components/surveys/SurveyForm.js
        export default reduxFrom()(SurveyForm);

---Redux Form in Practice---

For now remove the SurveyField components from the tree structure diagrams we will take care of that 
later. For now we just want to focus on the form itself. Start simple and later refactor in the 
SurveyField components.

Add the Field component from redux-form

    client/src/components/surveys/SurveyForm.js
        import { reduxForm, Field } from 'redux-form';

The Field helper renders ANY type of traditional form of HTML element:

    text areas, text inputs, file inpujts, check boxes, radio Buttons, drop downs

If you just add in the bare component like so --> <Field /> then you will get this failure:

    Warning: Failed prop type: The prop `name` is marked as required in `Field`, but its
     value is `undefined`. in Field (at SurveyForm.js:10)

to fix it add in these required fields:

    <Field 
        type="text"
        name="surveyTitle" <-- stores key(aka property) called 'surveyTitle' in Redux store
        component="input" <-- You can also pass in a component!! Such as {SurveyField}.
    />

---Custom Field Components---

Even though Stephen told us to use component="input" and not traditional <input /> tag you still use it.
ReduxForm has more power than this and is really this ability to render so many fields that's more
important than debating these input stuff.

---Wiring Up Custom Fields---
---DRY'ing Up Fields---
---Fields From Config---

This can be refactored

    client/src/components/surveys/SurveyForm.js
        renderFields() {
            return (
                <div>
                    <Field
                        label="Survey Title" 
                        type="text" 
                        name="title" 
                        component={SurveyField} 
                    />
                    <Field
                        label="Subject Line" 
                        type="text" 
                        name="subject" 
                        component={SurveyField} 
                    />
                    <Field
                        label="Email Body" 
                        type="text" 
                        name="body" 
                        component={SurveyField} 
                    />
                    <Field
                        label="Recipient List" 
                        type="text" 
                        name="emails" 
                        component={SurveyField} 
                    />
                </div>
            );
        }

to this

    const FIELDS = [ // list of distinct items.
        { label: 'Survey Title', name: 'title' },
        { label: 'Subject Line', name: 'subject'},
        { label: 'Email Body', name: 'body' },
        { label: 'Recipient List', name: 'emails' }
    ];

    class SurveyForm extends Component {
        renderFields() {
            return _.map(FIELDS, ({ label, name }) => { // ES6 destructuring. "Get me the label" and "Get me the name".
                return <Field component={SurveyField} type="text" label={label} name={name} />
            });
        }

You will get this warning afterwards.

    Warning: Each child in an array or iterator should have a unique "key" prop.

    Check the render method of `SurveyForm`. See https://fb.me/react-warning-keys for more information.
        in Field (at SurveyForm.js:19)

You are getting that warning because we are returning a list of <Field /> components with _.map().
Everytime you have a list like this in React you have to put in a key property. The key has to be unique 
so choose the 'name' property(key) in FIELDS array since it's uniqe across all of them.

    <Field key={name} ....

---Form Validation---

client/src/components/surveys/SurveyForm.js
    function validate(values) {
        const errors = {}; // Returned to redux and if it's empty it tells everything is good to go.

        // title coincides with the 'name' property assigned in FIELDS.
        if (values.title) {
            errors.title = 'You must provide a title';
        }

        return errors;
    }

---Showing Validation Errors---

client/src/components/surveys/SurveyField.js
    {touched && error}

The instant the form renders Redux form prints out all of the validation errors.
To solve this problem use the touch property.

---Showing Validation Errors--
---Generalizing Field Validation---

client/src/components/surveys/SurveyForm.js
    // REFACTOR to fill in additional error fields.
    // Use forEach loop because we are not trying to return a list here just modifying.
    _.each(FIELDS, ({ name }) => { // Pull out just 'name' property.
        if (!values[name]) {
            errors[name] = `You must provide a ${name}`;
        }
    });

The Recipient List is tricky since we need make sure the list of emails is formatted correctly.

---Validating Emails--

The Recipient List is tricky since we need make sure the list of emails is formatted correctly.
Must be separated by comma(space after command is ok too).

Seeing as how this type of email validator can be reused from other parts of an app it's best
to create a reusable funciton.

3:45