https://github.com/StepheGrider/FullstackReactCode
https://mlab.com/login/

Download most up to data node version.
https://nodejs.org/en/download/current/

Also, install npm version of at least 5.5.

-----Heroku Deployment Checklist-----

1) Dynamic Port Binding.

server/index.js
    const PORT = process.env.PORT || 5000;

2) Tell Heroku which nodejs version to use. By default, Heroku will try to use an old version of node, which will likely crash the app.

Video uses "node": "8.1.1", "npm": "5.0.3", but i'm using newer version.

server/package.json
    "engines": {
        "node": "8.9.1",
        "npm": "5.5.1" 
    }

3) Tell Heroku to startup nodejs server via start script.

From "sripts" remove "test": "echo \"Error: no test specified\" && exit 1" and add this.

"scripts": {
    "start": "node index.js"
  }

4) We dont want give Heroku our dependencies. We let Heroku decide installing those.

.gitignore
    node_modules


-----Verifying Heroku Deployment-----

jairomh@ubuntu64-DevOps:~/REACTfullStack/server$ heroku create
Creating app... done, â¬¢ aqueous-earth-73690
https://aqueous-earth-73690.herokuapp.com/ | https://git.heroku.com/aqueous-earth-73690.git


-----Overview of Passport JS-----

Passport will not do this well.
    Automates vast majority of the OAUTH flow but not the entire things.
    Passport library structure is composed of 2 libraries.
        passport(core that is always installed by you):
            General helpers for handling auth in Express apps.
        passport strategy(requires installing at least one of these):
            Helpers for authentication with on very specific method(email/password, Google, Facebook, etc.).
            If you want to have Google, Facebook, Twitter authentication then you need to install one passport strategy for each one.

-----Passport Setup-----

server$ npm install --save passport passport-google-oauth20

-----Enabling Google OAUTH API-----

Go here https://console.developers.google.com
Click on Add API and search for Google+ API since it contains OAUTH. 
Enable it. Create credentials. Click Oauth client ID.

Oauth clientID:  [check keys.js]
    This is public token and accessible to outside world that identifies application to Google server(s).
client secret:  [check keys.js`]
    Do not share this with anyone.

How to securely store your secret(text value) if you push it to Github?
    Create config/keys.js and in the keys.
    Add keys.js to .gitignore

        Oauth clientID = googleClientID (capital D is important)
        client secret = googleClientSecret

        Notice how we prepend with 'google' to decipher between other Oauth providers like Facebook.

-----Authorized redirected URIs-----

This URI is entirely security related so users dont get tricked by sending their flow over to some hacker.com

    redirect_uri=http%3A%2F%2Flocalhost%3A5000%2Fauth%2Fgoogle%2Fcallback&

Google will return this page at the start of all this auth setp so click on it.

    Visit https://console.developers.google.com/apis/credentials/oauthclient/864190731953-egqj70f75jtofjs2fvsbi2136ip7p72u.apps.googleusercontent.com?project=864190731953 to update the authorized redirect URIs.

    Then under 'Authorized redirect URIs' change http://localhost:5000/* to http://localhost:5000/auth/google/callback

-----OAuth Callbacks-----

Now try to hit http://localhost:5000/auth/google/. It will load a page with 'Cannot GET /auth/google/callback'
It will also load this in the browser URL bar. See it had the code!!!
    http://localhost:5000/auth/google/callback?code=4/fGudjAYLVSl3swMg2FEUufDV0YcrtNZcpv6sx-CiPHQ#

Hit http://localhost:5000/auth/google/ a second time to see our callback be told to execute.

    (accessToken) => { 
    console.log(accessToken);

-----Access and Refresh Tokens-----

-----Nodemon setup-----
REACTfullStack/server$ npm install --save nodemon

Append this to "scripts" section in package.json.
    
    dev": "nodemon index.js"

-----HTTP is Stateless-----

Ajax requests are still HTTP requests. HTTP is stateless.
Server gives us back a token. This token is used as proof by client to tell Server that it already
knows who the client is and the request is safe, since it has record of such token.

OAUTH will use cookie based authentication.

Header inside HTTP packet from Google server will have property 'Set-Cookie', which will hold
the token that will uniquely identify user.
The browser will strip off the token and store it in browser's memory.
Browser will then append that cookie to follow-up requests.
The REACT side of things knows nothing about the cookie authentication, which is great because
the browser will manage this all for us.

Cookie based approach does have shortcomings.
For example, different strategies like JSON web tokens(talk about it later).

-----Signing In Users with Oauth-----

For regular email/password login recognizing the user when they log in is straighforward.
But with Oauth for Google you have to use user's google Id because it will never change. over time.

    profile: { id: '103507278511115330517'

    Because we are placing out trust in Google if Google decides to change the id we are screwed.
    That's how Oauth works so we are making the ASSUMPTION the googleId will not change.
    As far as Oauth all we really care to know is just the Google Id.

-----Introduction to MongoDB-----

SQL                                               | NoSQL
==================================================|===============================================================
Table                                             | Collection(Array of objects(aka Document(s)))
Row/Record                                        | Document
Schema based(columns, column guaranteed to exist) | Schemaless(mix of fields, which is good for data mining)
column                                            | field

-----MonogDB Steup-----

Remote ohsthing of mongoDB is a lot easier then local hosting of it.
DBname: emaily-dev
    DBusername: <see config/key.js>
    DBpassword: <see config/key.js>

-----Connecting Mongoose to MongoDB(remote)-----

If you see or NOT see this warning it's fine. 

~/REACTfullStack/server$ node index.js 
(node:5297) DeprecationWarning: `open()` is deprecated in mongoose >= 4.11.0, use `openUri()` instead, or set the `useMongoClient` option if using `connect()` or `createConnection()`. See http://mongoosejs.com/docs/connections.html#use-mongo-client
Db.prototype.authenticate method will no longer be available in the next major release 3.x as MongoDB 3.6 will only allow auth against users in the admin db and will no longer allow multiple credentials on a socket. Please authenticate using MongoClient.connect with auth credentials.

Just shows how mongoose is interacting with mongoDB.
Until mongoose fixes this there's nothing we can do so get used to them and keep giong.

-----Mongoose Model Classes-----

Don't put models in index.js since that file is more for loading and booting up are app.
Shifting thoughts to mongoDB(not mongoose). MongoDB can have variant amounts of properties(fields) per record(row).
However, mongoose will kinda remove the variant and enforce a Schema.

-----Saving Model Instances(CREATES USER ON REMOTE MONGODB)-----

When is it an appropriate time to create this new user??

DO NOT export model class from User.js and import into passport.js because it will really mess
up future tests with mocha, jest, etc. This will cause you to create copies of the same user
model, which those testing frameworks will yell at. To resolve this do this.
Create model class in passport.js like this.

    passpost.js
        // !TIP:  1 arg means we are fetching out of mongoose.
        // 2 args means we are loading into mongoose.
        // This is our true model Class.
        const User = mongoose.model('users'); 

And leave this as is in User.js

    User.js
        // !TIP:  1 arg means we are fetching out of mongoose.
        // 2 args means we are loading into mongoose.
        mongoose.model('users', userSchema); // Again this loads schema into mongoose.

-----Mongoose Queries-----

serializeUser function is going to be called by passport with our user model that we fetch in the first login step.
Refer to 'fist login step' diagram in notes.txt.
We are going to use that user model as our identifying piece of user information.
This info will be passed back to passport.
Passport will stuff cookie into token and send token to user.

deserializeUser function will be called by passport when a user client with its cookie makes a request to our server.
A request such as 'Can I have a list of my posts?'.
deserializeUser function will turn cookie into unique user model that identifies user.
The user is the passed into passport telling passport the user is real and authenticated so let's give user their list
of posts that belong to them.

-----Deserialize Cookies-----

-----Enabling Cookies-----

Out of the box express has no idea how to handle cookies.
To manage cookies in our app.

~/REACTfullStack/server$ npm install --save cookie-session

Then add them into

    passport.js
        const cookieSession = require('cookie-session'); // Give access to cookies.
        const passport = require('passport'); // Makes use of cookies.

and into

    index.js
        app.use(
            cookieSession({
        app.use(passport.initialize());
        app.use(passport.session());

-----Testing Authentication-----

    authroutes.js
        req.user is short for request.user.

            app.get('/api/current_user', (req, res) => {
                res.send(req.user);
            });

To see if you're getting your cookie go to here again.
http://localhost:5000/auth/google

Then go here to see userid.
localhost:5000/api/current_user

Order of execution

1. Hit http://localhost:5000/auth/google

passport.js
    passport.use()
        EXISTING-USER: { _id: 5a344062d0f94726d34da9ef,
        googleId: '103507278511115330517',
        __v: 0 }
        SERIALIZEUSER: { _id: 5a344062d0f94726d34da9ef,
        googleId: '103507278511115330517',
        __v: 0 }
        DESERIALIZEUSER: { _id: 5a344062d0f94726d34da9ef,
        googleId: '103507278511115330517',
        __v: 0 }

2. Hit localhost:5000/api/current_user

authroute.js
    req.user: { _id: 5a344062d0f94726d34da9ef,
    googleId: '103507278511115330517',
    __v: 0 }

-----Logging Out Users-----

authroutes.js
    app.get('/api/logout', (req, res) => {
        req.logout(); // Kills user's id in cookie basically makes it to where you no longer are that user.
        res.send(`Logging out: ${req.user}`); // Send to user proof they are no longer signed in.
    });

3. Test logout
Hit localhost:5000/api/logout and you should see a blank screen or it could load with just null.

4. Test if user is logged in.
Hit localhost:5000/api/current_user and you should see a blank screen since req.user has been killed.
Thus res.send(req.user) should push blank output.

-----[Optional] A Deeper Dive-----

app.use() is middleware.
They can execute on incoming requests before they are sent to route handlers.
Every app.use() function you see is its own middleware.

cookie-session stores all the data directly in the cookie. In other words 'Cookie is the session.'
    - Limited to 14KB of stuffing data into the cookie session. A userid is well below limit.
    - You dont' have to use 'Compatible Session Stores' like that in express-session.
express-session stores a reference that ponits to the data at a remote server. In other words 'Cookie references a session.'
    - Advantage is that it can store a lot of remote session data.

-----Dev vs Product Keys-----

Curently we have one set of keys in config/keys.js.
Best to do two separate sets of keys.
Production keys will be stored on Heroku and Dev keys will be on your machine.

    -----Generating Production Resources-----

1. Setup production mongoDB by creating.

    DB username: jairoprod; passwd: password

2. Setup production version of Google API. Remember, we have to go to console.developers.google.com

    - Create a new separate project to isolate away from emaily-dev and called it emaily-prod.
    - Select Google+ to create Oauth 2.0 API. 
    - Then click create credentials to make OAuth client ID.
        Configure product anme on Consent Screen before moving forward. 
        This is where you can put URL and logo if you were doing thi at a real job.
        At least fil in 'Product name' as Emaily. It makes no sense to put in Emaily-prod since this is what users will see.
        It is just to tell users who they are granting access too.

    ----Heroku Env Variables-----

Under Heroku app SETTINGS clikc 'Reveal Config Vars' and put ke/value:
    GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, MONGO_URI, COOKIE_KEY

    When creating COOKIE_KEY in HEROku type in a long random one of letters and numbers.
    MONGO_URI is mongodb://jairoprod:password@ds063134.mlab.com:63134/emaily-prod

After you deploy to git and then git heroku go there to start Oauth flow

    https://aqueous-earth-73690.herokuapp.com/auth/google

you should get 400 Error: redirect_uri_mismatch.'

    ----Fixing Heroku Proxy Issues-----

Cause of the 400 Error: redirect_uri_mismatch.' is because google is redirecting using http when inside the console.developer
api we speicified https.

    Choose your fix preference. Both are easy but option 2 is easier.

    1. Inside passport.js one can put the full URL path by adding say key

        googleRedirectURI: 'https://aqueous-earth-73690.herokuapp.com/auth/google'

        in prod.js and substituing the key into callbackURL in passport.js.

        callbackURL: '/auth/google/callback'

    2. Add proxy: true into passport.js.

Close browser and reload https://aqueous-earth-73690.herokuapp.com/auth/google.
You should now get this to show it's working.

    Cannot GET /auth/google/callback

And this should be working too.
    https://aqueous-earth-73690.herokuapp.com/api/current_user
    
    {
        _id: "5a42b00eda6c8800146b52a8",
        googleId: "103507278511115330517",
        __v: 0
    }

----React App Generation-----

Google 'create react app' to download popular tool for building React apps.
    https://github.com/facebookincubator/create-react-app

Install tool as global npm module to then generate a new React project.
~/REACTfullStack/server$ npm install -g create-react-app

Now Generate React project.
~/REACTfullStack/server$ create-react-app client

----A separate Front End Server-----

client folder has its own built-in server!!

~/REACTfullStack/server$ cd client/
~/REACTfullStack/server/client$ ls
node_modules  package.json  package-lock.json  public  README.md  src

In order to run the React side you have to be in client folder to run npm start.
~/REACTfullStack/server/client$ npm start

    Compiled successfully!

    You can now view client in the browser.

    Local:            http://localhost:3000/
    On Your Network:  http://192.168.1.72:3000/

    Note that the development build is not optimized.
    To create a production build, use npm run build.

This will also open the React browser page.

WHY USE create-react-app TOOL AND NOT JUST STICK WITH EXPRESS SERVER TO BUILD REACT PORTION??
    ANSWER: It's a little hard to do it with EXPRESS but you can, but create-react-app has so much
    prebuilt configuration that will save us so much time trying to wire webpack/babel/devServer.
    All this stuff we get out of the box for free. It allows React server and EXPRESS server work 
    together nicely.

----Running the Client and Server----

To run the REACT client server add this script to server/package.json. The flag --prefix executes client server from 'client' folder.

    server/package.json
        "client": "npm run start --prefix client"

THIS IS NOT NECESSARY SINCE YOU CAN STILL RUN EACH SERVER IN A SEPARATE CLI SESSOIN, BUT IT'S HANDY.

Now combine both "dev" and "client" scripts.
First, change "dev" to "server" to keep names functional consitent.
Then add new "dev" script to start both "server" and "client" concurrently.

    server/package.json
        "dev": "concurrently \"npm run server\" \"npm run client\""

Finally install concurrently as npm module.

----Routing Stumbling Block----

~/REACTfullStack/server$ npm install --save concurrently

This is naive because this href attribute implies relative domain path

    <a href="/auth/google">Sign In With Google</a>
    
which points to http://localhost:3000/auth/google

but how do you get it to know to route to local dev vs. ermote hoerku.
Solution is to add this to client/src/packgae.json

    "proxy": {
        "/auth/google": {
        "target": "http://localhost:5000"
        }
    },

When clicking on our React home page the 'Sign In with Google' link should takes us back to the 
Google 400 Error: redirect_uri_mismatch wihch means we are now hitting our Oauth Flow.

    ----The Beauty of Create React App's Proxy----

On our DEV side both the create-react-server and Express server handle requests.
Front-end requests are hanled by create-react-server and backend request by Express server.
On Heroku Express hanldes both.

Only add this to the DEV side since we can allow for lesser security.
Click on link shown on the Google 400 Error: redirect_uri_mismatch webpage.

https://console.developers.google.com/apis/credentials/oauthclient/864190731953-egqj70f75jtofjs2fvsbi2136ip7p72u.apps.googleusercontent.com?project=864190731953

Then add port 3000 into 'Authorized redirect URIs' field on your console.developers page.

http://localhost:3000/auth/google/callback

THE CHANGE TAKES A MINUTE OR TWO TO UPDATE THE CHANGES TO OTHER GOOGLE SERVERS.

Now you should be able to hit port 3000 Oauth flow with http://localhost:3000/auth/google, which loads page:
    Cannot GET /auth/google/callback

FOR PRODUCTION when webpack and babel builds the production file inside your DEV create-react-app it will auto-configure 
the missing proxy for production for you and place it into client/build folder...build folder is created after running
'npm run build'.

    client/package.json.
    "proxy": {
        "/auth/google": {
        "target": "http://localhost:5000" <-- THIS WILL BE REPLACED IN PRODUCTION. ONLY REQUIRED FOR DEV.

You can quickly do a test to create your React app with 'npm run build' it will show this message.

    $ cd client; npm run build;
    
    Creating an optimized production build...

IMPORTANT POINT!!
    The reason this all works in both DEV and PROD is because the browser already prepends the base URL domain to your 
    href link so we dont need any crazy routes.

    client/src/App.js
        <!-- TRANSLATES TO href="http://localhost:5000/auth/google" WHEN IN DEV OR FULL HEROKU LINK WHEN IN PROD. -->
        <a href="/auth/google">Sign In With Google</a> 

    ---[Optional] Why This Architecture?--- (SEE DIAGRAM)

---Frontend Tech-----------------------------------------------

Delete these boilerplate files except for registerServiceWorker.js.

~/REACTfullStack/server$ ls -lh client/src/
total 28K
-rw-rw-r-- 1 jairomh jairomh  377 Dec 26 14:45 App.css
-rw-rw-r-- 1 jairomh jairomh  588 Dec 26 16:52 App.js
-rw-rw-r-- 1 jairomh jairomh  208 Dec 26 14:45 App.test.js
-rw-rw-r-- 1 jairomh jairomh   63 Dec 26 14:45 index.css
-rw-rw-r-- 1 jairomh jairomh  254 Dec 26 14:45 index.js
-rw-rw-r-- 1 jairomh jairomh 2.7K Dec 26 14:45 logo.svg
-rw-rw-r-- 1 jairomh jairomh 4.0K Dec 26 14:45 registerServiceWorker.js <-- KEEP THIS ONE

See Digrams.
    client/src/index.js -- DATA LAYER CONTROL(REDUX)
    client/src/App.js -- RENDERING LAYER CONTROL(React Router)

Under client side install react packages.
    ~/REACTfullStack/server/client$ npm install --save redux react-redux react-router-dom

Create blank index.js under client/src.

If .js file starts with a capital letter then it's exporting class based component.
If if starts with lower case then the file is exporting a function component.
Note:  Use of 'import' keyword is supported since frontend makes use of Babel/Webpack.

client/src/public/index.html houses React side of our app.

    ---Troubelshooting NPM--

If you see this error

    events.js:183
      throw er; // Unhandled 'error' event
      ^
      .....
    npm ERR! code ELIFECYCLE
    npm ERR! errno 1
    npm ERR! client@0.1.0 start: `react-scripts start`
    npm ERR! Exit status 1

simply delete package-lock.jsom from client/ folder and cd into it then run 'npm install'.
If that does not work run 'npm install' and 'npm update' and reboot.

---Redux Review and Setup---(SEE DIAGRAM)

Redux store is where all our state exists.
To determine state or to change it call an action creator to dispatch(aka returns) actions.
Action is sent to reducer(s).
Those reducers are combined together with combineReducers call, which updates state in our redux store.

Remember, Provider component from React-Redux library is the bonding glue between reacd and redux.
It's placed at the very parent component of our app so any sub-components(no matter how nested) 
now access that GLOBAL state. The Provider component monitors for state changes in Redux store the
Provider will inform all of its children components of the new state and update those components
with the new state.

After configure provider be sure to test your "Hi there!" webapge is still loading.

    client/src/index.js
        <Provider store={store}><App/></Provider>

---The Auth Reducer---

After making client/src/reducers/authReducers.js and it's matching index.js test "Hi there!"
webpage is still loading.

---Why We Care About Auth---

Main login page Header component will change in some fashion when user logs in to say we're logged in.

    React Router Setup---

A route is a pairing between the URL address a user is looking at and the components shared on the screen.
Routes will be placed in App.js. Remember index.js is our top-level for Redux state data setup.

App.js
    // BrowserRouter is the brains of react-router and tells it how to behave. It looks at current URL
    // and changes set of components visible on the screen.
    // Route component sets up a rule between user visited route and visible set of components.
    import { BrowserRouter, Route } from 'react-router-dom';

GOTCHA: BrowserRouter component can at most just have one child. For example, each <div><div/> represents 
a child so have two like this will produce an error.

    <BrowserRouter>
        <div><div/> -- 2 div's produce error.
        <div><div/>  
    </BrowserRouter>

Assuming user went to top path URL emaily.com then REACT root path of app would be /.

    <Route path="/" component={Landing} />

---Always Visible Components---

Routes are "reverse" greedy matched meaning localhost:3000/ only matches
    <Route path="/" component={Landing} />

but localhost:3000/surveys matches both
    <Route path="/" component={Landing} />
    <Route path="/surveys" component={Dashboard} />

trick is to use 'exact' property on "/"
    <Route exact path="/" component={Landing} /> -- BY DEFAULT 'exact' is same as writing 'exact={true}'

---Materialize CSS---

http://materializecss.com/

cd into client folder
~/REACTfullStack/server/client$ npm install --save materialize-css

---Webpack with CSS---

When we installed create-react-app' it came with Webpack.
Webpack can also import CSS files and include it in its bundled files.
You could put the import statement in client/src/index.js or App.js. It's your preference
on how its placement makes sense to you.
Since this is not .js file you have to specifiy .css extension and webpack knows to look in npm 
folder since we did not specify a './' at the beginning of the path.

client/src/index.js 
    import 'materialize-css/dist/materialize.min.css';

---Current User API---

When our app boots up this will determine if a user is signed in.
If it returs none then we know we are not logged in.

authroutes.js
    app.get('/api/current_user', (req, res) => {

To do this we make an ajax request from the React client side.

---Additional Proxy Rules---

Install axios so client side can make ajax requests to our backend API and redux-thunk 
to make asynchronous action creators behave the way we expect.

~/REACTfullStack/server/client$ pwd
/home/jairomh/REACTfullStack/server/client
~/REACTfullStack/server/client$ npm install --save axios redux-thunk

client/src/actions/index.js

    const fetchUser = () => {
        // Only needs relative path, which goes back to long discussion about 
        // how root URL is prepended in both DEV and PROD environment.
        axios.get('/api/current_user')
    };

Then be sure to add proxy rule in client/package.json.
    "/api/*"

---Basics of Redux Thunk(SEE DIAGRAM)---

Idea behind redux-thunk is that it breaks the rule an action creator needs to immediately
return and action. With redux-thunk it doesnt have to be immediate.

With help of redux-thunk it allows us to dispatch action only when axios get promise request has been resolved.

---Testing fetchUser---

Add this line

    authReducer.js
        console.log('ACTION:', action);

to test if fetchUser action creator is dispatching reducer after setting redux-thunk and redux.

    client/src/components/App.js
        componentDidMount() {
            // tied in with connect() below to allow seeing fetchUser from actions/index.js
            this.props.fetchUser(); 
        }

        // 1st is map-state-to-prop function <-- null
        // 2nd options is action creator(s) being passed
        // 'actions' is now assigned to App component as props
        // thus are accessible with this.props.
        export default connect(null, actions)(App); 