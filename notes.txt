https://github.com/StepheGrider/FullstackReactCode

Download most up to data node version.
https://nodejs.org/en/download/current/

Also, install npm version of at least 5.5.

-----Heroku Deployment Checklist-----

1) Dynamic Port Binding.

server/index.js
    const PORT = process.env.PORT || 5000;

2) Tell Heroku which nodejs version to use. By default, Heroku will try to use an old version of node, which will likely crash the app.

Video uses "node": "8.1.1", "npm": "5.0.3", but i'm using newer version.

server/package.json
    "engines": {
        "node": "8.9.1",
        "npm": "5.5.1" 
    }

3) Tell Heroku to startup nodejs server via start script.

From "sripts" remove "test": "echo \"Error: no test specified\" && exit 1" and add this.

"scripts": {
    "start": "node index.js"
  }

4) We dont want give Heroku our dependencies. We let Heroku decide installing those.

.gitignore
    node_modules


-----Verifying Heroku Deployment-----

jairomh@ubuntu64-DevOps:~/REACTfullStack/server$ heroku create
Creating app... done, â¬¢ aqueous-earth-73690
https://aqueous-earth-73690.herokuapp.com/ | https://git.heroku.com/aqueous-earth-73690.git


-----Overview of Passport JS-----

Passport will not do this well.
    Automates vast majority of the OAUTH flow but not the entire things.
    Passport library structure is composed of 2 libraries.
        passport(core that is always installed by you):
            General helpers for handling auth in Express apps.
        passport strategy(requires installing at least one of these):
            Helpers for authentication with on very specific method(email/password, Google, Facebook, etc.).
            If you want to have Google, Facebook, Twitter authentication then you need to install one passport strategy for each one.

-----Passport Setup-----

server$ npm install --save passport passport-google-oauth20

-----Enabling Google OAUTH API-----

Go here https://console.developers.google.com
Click on Add API and search for Google+ API since it contains OAUTH. 
Enable it. Create credentials. Click Oauth client ID.

Oauth clientID:  [check keys.js]
    This is public token and accessible to outside world that identifies application to Google server(s).
client secret:  [check keys.js`]
    Do not share this with anyone.

How to securely store your secret(text value) if you push it to Github?
    Create config/keys.js and in the keys.
    Add keys.js to .gitignore

        Oauth clientID = googleClientID (capital D is important)
        client secret = googleClientSecret

        Notice how we prepend with 'google' to decipher between other Oauth providers like Facebook.

-----Authorized redirected URIs-----

This URI is entirely security related so users dont get tricked by sending their flow over to some hacker.com

    redirect_uri=http%3A%2F%2Flocalhost%3A5000%2Fauth%2Fgoogle%2Fcallback&

Google will return this page at the start of all this auth setp so lcick no it.

    Visit https://console.developers.google.com/apis/credentials/oauthclient/864190731953-egqj70f75jtofjs2fvsbi2136ip7p72u.apps.googleusercontent.com?project=864190731953 to update the authorized redirect URIs.

    Then under 'Authorized redirect URIs' change http://localhost:5000/* to http://localhost:5000/auth/google/callback

-----OAuth Callbacks-----

Now try to hit http://localhost:5000/auth/google/. It will load a page with 'Cannot GET /auth/google/callback'
It will also load this in the browser URL bar. See it had the code!!!
    http://localhost:5000/auth/google/callback?code=4/fGudjAYLVSl3swMg2FEUufDV0YcrtNZcpv6sx-CiPHQ#

Hit http://localhost:5000/auth/google/ a second time to see our callback be told to execute.

    (accessToken) => { 
    console.log(accessToken);

-----Access and Refresh Tokens-----

-----Nodemon setup-----
REACTfullStack/server$ npm install --save nodemon

Append this to "scripts" section in package.json.
    
    dev": "nodemon index.js"

-----HTTP is Stateless-----

Ajax requests are still HTTP requests. HTTP is stateless.
Server gives us back a token. This token is used as proof by client to tell Server that it already
knows who the client is and the request is safe, since it has record of such token.

OAUTH will use cookie based authentication.

Header inside HTTP packet from Google server will have property 'Set-Cookie', which will hold
the token that will uniquely identify user.
The browser will strip off the token and store it in browser's memory.
Browser will then append that cookie to follow-up requests.
The REACT side of things knows nothing about the cookie authentication, which is great because
the browser will manage this all for us.

Cookie based approach does have shortcomings.
For example, different strategies like JSON web tokens(talk about it later).

-----Signing In Users with Oauth-----

For regular email/password login recognizing the user when they log in is straighforward.
But with Oauth for Google you have to use user's google Id because it will never change. over time.

    profile: { id: '103507278511115330517'

    Because we are placing out trust in Google if Google decides to change the id we are screwed.
    That's how Oauth works so we are making the ASSUMPTION the googleId will not change.
    As far as Oauth all we really care to know is just the Google Id.

-----Introduction to MongoDB-----

SQL                                               | NoSQL
==================================================|===============================================================
Table                                             | Collection(Array of objects(aka Document(s)))
Row/Record                                        | Document
Schema based(columns, column guaranteed to exist) | Schemaless(mix of fields, which is good for data mining)
column                                            | field

-----MonogDB Steup-----

Remote ohsthing of mongoDB is a lot easier then local hosting of it.
